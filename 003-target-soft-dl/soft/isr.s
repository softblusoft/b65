; Copyright 2023 Luca Bertossi
;
; This file is part of B65.
; 
;     B65 is free software: you can redistribute it and/or modify
;     it under the terms of the GNU General Public License as published by
;     the Free Software Foundation, either version 3 of the License, or
;     (at your option) any later version.
; 
;     B65 is distributed in the hope that it will be useful,
;     but WITHOUT ANY WARRANTY; without even the implied warranty of
;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;     GNU General Public License for more details.
; 
;     You should have received a copy of the GNU General Public License
;     along with B65.  If not, see <http://www.gnu.org/licenses/>.

; this file is a modified version from the guide at https://cc65.github.io/doc/customizing.html

; ---------------------------------------------------------------------------
; interrupt.s
; ---------------------------------------------------------------------------
;
; Interrupt handlers

; C interrupt handler notes from the cc65 manual (FAQ section):
;
; As any non  trivial  6502 program, the code  generated by cc65 makes use of the zero page.
; Zero page  locations  are also used  for the  argument stack, and as temporary storage for
; most of the  runtime  support  functions. So  when writing interrupt  handlers in C, it is
; necessary to save the CPU  registers plus these  zero page locations. In addition to that,
; the functions that manipulate  the stack  pointer are  not reentrant, so you have to setup
; a separate stack for the interrupt handler.

; This means that  interrupt handlers cannot be  done without  some assembler code. For many
; applications, the  wrapper code written  in assembler is more  than what has to be done in
; the interrupt handler itself, so I do usually suggest to think about writing the interrupt
; handler  completely in  assembler (provided  it is rather short). If you  don't want to do
; this  for some  reason or  another, you  may  want  to have  a look  at the  break handler
; functions in libsrc/dbg/dbgsupp.s. They do  contain all code that would also be needed for
; an interrupt handler (saving registers and zero page locations, calling a C function). 

; Moreover from https://cc65.github.io/mailarchive/2004-10/4623.html
; [...] The overhead for saving and  restoring the zero  page locations used by the compiler
; and runtime  is so high that I would  still advise people  to write  interrupt handlers in
; assembler.

.export   _irq_int, _nmi_int
.import   _g_uart_rx_count

.segment  "CODE"

.PC02                             ; Force 65C02 assembly mode

; ---------------------------------------------------------------------------
; Non-maskable interrupt (NMI) service routine

_nmi_int:  
           ; Disable interrupts
           SEI

           PHX                    ; Save X register contents to stack
           TSX                    ; Transfer stack pointer to X
           PHA                    ; Save accumulator contents to stack
           INX                    ; Increment X so it points to the status
           INX                    ;   register value saved on the stack
           LDA $100,X             ; Load status register contents
           AND #$10               ; Isolate B status bit
           BNE irq_halt           ; If B = 1, BRK detected

            ; Interrupt code handler starts here

           JMP irq_ret

; ---------------------------------------------------------------------------
; Maskable interrupt (IRQ) service routine

_irq_int:  
           ; Disable interrupts
           SEI

           PHX                    ; Save X register contents to stack
           TSX                    ; Transfer stack pointer to X
           PHA                    ; Save accumulator contents to stack
           INX                    ; Increment X so it points to the status
           INX                    ;   register value saved on the stack
           LDA $100,X             ; Load status register contents
           AND #$10               ; Isolate B status bit
           BNE irq_halt           ; If B = 1, BRK detected

            ; Interrupt code handler starts here
            
            ; If UART interrupt update _g_uart_rx_count
			;   if (REGEXT0_MODE & 0x10)
			;       _g_uart_rx_count = REGEXTD_RX_COUNT;
			;
            LDA $DC00             ; Load Extension register 0
			AND #$10              ; Extract Isolate bit 4 (UART Rx interrupt)
            BEQ _irq_clean        ; if not UART interrupt goto bit clean
			LDA $DC0D             ; Load REGEXTD_RX_COUNT
            STA _g_uart_rx_count  ; Copy loaded value to _g_uart_rx_count

_irq_clean:
            ; Clear bit 3,4 at 0xDC00
			;   REGEXT0_MODE &= 0xE7;
			;
            LDA #$E7            ; Set A  = 0xE7
            AND $DC00           ; Set A &= (the value at 0xDC00)
            STA $DC00           ; Save A to 0xDC00

; ---------------------------------------------------------------------------
; IRQ return

irq_ret:   PLA                    ; Restore accumulator contents
           PLX                    ; Restore X register contents
           
            ; Enable interrupts
            CLI
           
           RTI                    ; Return from all IRQ interrupts

; ---------------------------------------------------------------------------
; BRK detected, stop

irq_halt:  JMP irq_halt           ; If BRK is detected, something very bad
                                  ;   has happened, so stop running
